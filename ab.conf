
resolver 127.0.0.11 ipv6=off;

init_by_lua_block {
  cjson = require "cjson"
  cjson.encode_empty_table_as_object(false)
  redis = require "resty.redis"
  set_headers = function()
    ngx.header['Content-Type'] = 'application/json; charset=utf8'
    local origin = ngx.req.get_headers()['Origin']
    if origin then
      ngx.header['Access-Control-Allow-Origin'] = origin
      ngx.header['Access-Control-Allow-Credentials'] = 'true'
      ngx.header['Access-Control-Allow-Methods'] = 'POST, GET, OPTIONS, PUT, DELETE'
      ngx.header['Access-Control-Allow-Headers'] = 'X-Session-Id, X-Version, X-Env'
    end
  end
  response = function(status, code, message)
    set_headers()
    ngx.print(cjson.encode({ code=code, msg=message }))
    ngx.exit(status)
  end
  response_value = function(val, test)
    if test.type == "number" then
      val = tonumber(val)
    end
    set_headers()
    ngx.print(cjson.encode({
      code=0, msg='success',
      type=test.type, test=test.name, layer=test.layer, value=val,
    }))
    ngx.exit(200)
  end
  connect_redis = function(penv)
    local red = redis:new()
    red:set_timeouts(100, 200, 200)
    local ok, err = red:connect('redis', 6379) -- docker-compose里面定义了link
    if not ok then
      response(500, 1, 'can not connect redis')
    end
    red:select((penv or env()) == 'production' and 1 or 0) -- 测试环境实验db0,正式环境实验db1
    -- ngx.log(ngx.ERR, 'success to connect redis')
    return red
  end
  close_redis = function(red)
    local ok, err = red:set_keepalive(10000, 100)
    if not ok then
      response(500, 1, 'failed to set keepalive: ' .. err)
    end
  end
  arg = function(name, default)
    local var = ngx.var['arg_' .. name]
    if not var or var == '' then
      local header = ngx.req.get_headers()[name]
      if not header or header == '' then
        if default then
          return default
        end
        response(400, 1, name .. ' is required')
      end
      return header
    end
    return ngx.unescape_uri(var)
  end
  env = function()
    return ngx.req.get_headers()['X-Env']
  end
  get_user_id = function()
    local user_id = ngx.req.get_headers()['X-User-Id']
    if user_id and user_id ~= '' then
      return user_id
    end
    local sid = ngx.req.get_headers()['X-Session-Id']
    if not sid or sid == '' then
      response(400, -1, 'session_id is required')
    end
    local session_server = env() == 'production' and '10.0.0.32' or '10.0.0.17'
    local red = redis:new()
    red:set_timeouts(100, 200, 200)
    local ok, err = red:connect(session_server, 6379)
    if not ok then
      response(500, 1, 'can not connect redis')
    end
    red:select(1)
    -- ngx.log(ngx.ERR, 'success to connect redis')
    local res, err = red:get("carol:sid:" .. sid)
    if not res then
      ngx.log(ngx.ERR, "failed to get carol_user_id: ", err)
      return response(403, -1, 'can not get user_id')
    end
    if type(res) == "string" then
      local carol_user_id = cjson.decode(res)['user_id']
      if carol_user_id then
        return carol_user_id
      end
    end
    return response(400, -1, 'can not get user_id')
  end
}

init_worker_by_lua_block {
  local delay = 60 -- 一分钟运行一次
  local handler
  handler = function (premature)
    -- do some routine job in Lua just like a cron job
    local red = connect_redis('dev')
    local i, j, version, target
    -- docker-compose exec redis redis-cli script load "$(cat lua/redis-aggregate.lua)"
    local sha = 'ccc1b1d9bc24488e4d5079ac63c9850196226524'

    local versions, err = red:smembers("versions")
    local targets, err = red:smembers("targets")
    for i, version in ipairs(versions) do
      local version_var_name, err = red:hget('version:' .. version, 'var_name')
      local status, err = red:hget('var:' .. version_var_name, 'status')
      if status == 'running' then -- 只有运行中的实验才计算
        local aggr, aerr = red:evalsha(sha, 1, 'uv:' .. version)
        if not aerr then
          local uv, pv, min, max = unpack(aggr)
          red:hmset('version:' .. version, 'pv', pv, 'uv', uv, 'uv:min', min, 'uv:max', max)
          for j, target in ipairs(targets) do
            local target_var_name = red:hget('target:' .. target, 'var_name')
            if target_var_name == version_var_name then -- 只有版本和指标属于同一个实验才计算转化率
              -- ngx.log(ngx.ERR, "version_var_name == target_var_name", version_var_name, target_var_name)
              local taggr, taerr = red:evalsha(sha, 1, 'track:' .. version .. ':' .. target)
              if not taerr then
                local tuv, tpv, tmin, tmax = unpack(taggr)
                red:hmset(
                  'version:' .. version,
                  target .. ':count', tpv,
                  target .. ':user', tuv,
                  target .. ':min', tmin,
                  target .. ':max', tmax,
                )
                -- ngx.log(ngx.ERR, "pv, uv, tpv, tuv: ", cjson.encode({version, target, pv, uv or 0, tpv, tuv or 0}))
              end
            end
          end
        end
      end
    end
    close_redis(red)

    if premature then
      return
    end
    local ok, err = ngx.timer.at(delay, handler)
    if not ok then
      ngx.log(ngx.ERR, "failed to create the timer: ", err)
      return
    end
  end

  local ok, err = ngx.timer.at(delay, handler)
  if not ok then
    ngx.log(ngx.ERR, "failed to create the timer: ", err)
    return
  end
}

server {
  listen       80 default_server;
  location = /ab/layers {
    content_by_lua_block {
      local red = connect_redis()
      local res, err = red:smembers("layers")
      if err then
        close_redis(red)
        return response(500, 1, 'get layers failed')
      end
      close_redis(red)
      set_headers()
      ngx.print(cjson.encode({
        code=0, msg='success',
        layers=res,
      }))
      ngx.exit(200)
    }
  }
  location = /ab/layer/add {
    content_by_lua_block {
      local layer_name = arg('layer')
      local red = connect_redis()
      -- docker-compose exec redis redis-cli script load "$(cat lua/add-layer.lua)"
      local sha = '8d15964e64deda53894b22ad4fd7abf8885911d0'
      local res, err = red:evalsha(sha, 0, layer_name)
      if err then
        response(500, -1, err)
      else
        local code, msg = unpack(res)
        response(code == 1 and 200 or 500, code, msg)
      end
      close_redis(red)
    }
  }
  location = /ab/layer/weight {
    content_by_lua_block {
      local layer_name = arg('layer')
      local var_name = arg('var')
      local weight = tonumber(arg('weight'))
      -- TODO sum(weight) = 100
      if weight < 0 or  weight > 100 then
        return response(400, 1, 'weight is not validate')
      end
      -- docker-compose exec redis redis-cli script load "$(cat lua/layer-weight.lua)"
      local sha = "be118064ee651623d3c7af26f5ab2ef207e46a0b"
      local red = connect_redis()
      local res, err = red:evalsha(sha, 0, layer_name, var_name, weight)
      if err then
        response(500, -1, err)
      else
        local code, msg = unpack(res)
        response(code == 1 and 200 or 500, code, msg)
      end
      close_redis(red)
    }
  }
  location = /ab/tests {
    content_by_lua_block {
      local red = connect_redis()
      -- sort vars by nosort get # get *->name get *->layer get *->type get *->status get *->default
      local res, err = red:sort(
        "vars", 'by', 'var:*->modified',
        'get', '#', 'get', 'var:*->name',
        'get', 'var:*->layer', 'get', 'var:*->type', 'get', 'var:*->status',
        'get', 'var:*->default', 'get', 'var:*->created', 'get', 'var:*->modified',
        'get', 'var:*->weight',
        'DESC'
      )
      if err then
        close_redis(red)
        return response(500, 1, 'get test failed')
      end
      close_redis(red)
      set_headers()
      ngx.print(cjson.encode({
        code=0, msg='success',
        tests=res,
      }))
      ngx.exit(200)
    }
  }
  location = /ab/test/action {
    content_by_lua_block {
      local var_name = arg('var')
      local action = arg('action')
      if action == 'running' or action == 'stoped' or action == 'deleted' then
        local red = connect_redis()
        local res, err = red:sismember("vars", var_name)
        if err or res == 0 then
          close_redis(red)
          return response(404, 1, 'var_name: ' .. var_name .. ' not exists, edit var failed.')
        end
        local res, err = red:hmset('var:' .. var_name, 'status', action, 'modified', ngx.time())
        if err then
          close_redis(red)
          return response(500, 1, 'set var failed, var_name: ' .. var_name)
        end
        close_redis(red)
      end
      response(200, 0, 'edit test success')
    }
  }
  location = /ab/test/add {
    content_by_lua_block {
      local layer_name = arg('layer')
      local layer_weight = tonumber(arg('layer_weight'))
      if layer_weight < 0 or  layer_weight > 100 then
        return response(400, 1, 'layer_weight is not validate')
      end
      local var_name = arg('var')
      local test_name = arg('test_name')
      local type = arg('type')
      local default = arg('default')

      local red = connect_redis()
      local res, err = red:sismember("layers", layer_name)
      if err or res == 0 then
        close_redis(red)
        return response(404, 1, 'layer_name: ' .. layer_name .. ' not exists, add var failed.')
      end
      local res, err = red:sismember("vars", var_name)
      if err or res > 0 then
        close_redis(red)
        return response(404, 1, 'var_name: ' .. var_name .. ' exists, add var failed.')
      end
      local res, err = red:sadd('vars', var_name)
      if err then
        close_redis(red)
        return response(500, 1, 'add var: ' .. var_name .. ' to vars failed.')
      end
      local res, err = red:hmset(
        'var:' .. var_name,
        'layer', layer_name, 'name', test_name,
        'weight', weight, 'type', type, 'default', default,
        'status', 'init', 'created', ngx.time(), 'modified', ngx.time()
      )
      if err then
        close_redis(red)
        return response(500, 1, 'save var: ' .. var_name .. ' failed.')
      end

      local res, err = red:zadd('layer:' .. layer_name, layer_weight, var_name)
      if err then
        close_redis(red)
        return response(500, 1, 'edit layer: ' .. layer_name .. ' failed. var_name: ' .. var_name)
      end
      local res, err = red:zadd('value:' .. var_name, 100, default)
      if err then
        close_redis(red)
        return response(500, 1, 'edit var: ' .. var_name .. ' failed. value: ' .. default)
      end
      local res, err = red:sadd('versions', var_name .. ':' .. default)
      if err then
        close_redis(red)
        return response(500, 1, 'error to save to global versions')
      end
      local res, err = red:hmset(
        'version:' .. var_name .. ':' .. default,
        'value', default, 'name', '默认版本', 'weight', 100,
        'var_name', var_name, 'modified', ngx.time()
      )
      if err then
        close_redis(red)
        return response(500, 1, 'error to save version')
      end

      close_redis(red)
      response(200, 0, 'edit test success')
    }
  }
  location = /ab/test/weight {
    content_by_lua_block {
      local var_name = arg('var')
      local red = connect_redis()
      local res, err = red:sismember("vars", var_name)
      if err or res == 0 then
        close_redis(red)
        return response(404, 1, 'var_name: ' .. var_name .. ' not exists, edit var failed.')
      end
      local value = arg('val')
      local name = arg('name', value)
      local weight = tonumber(arg('weight'))
      if weight < 0 or  weight > 100 then
        return response(400, 1, 'weight is not validate')
      end
      local res, err = red:zadd('value:' .. var_name, weight, value)
      if err then
        close_redis(red)
        return response(500, 1, 'edit var: ' .. var_name .. ' failed. value: ' .. value)
      end
      local res, err = red:del('user:value:' .. var_name)
      if err then
        close_redis(red)
        return response(500, 1, 'remove user_val for var: ' .. var_name .. ' failed.')
      end
      local res, err = red:sadd('versions', var_name .. ':' .. value)
      if err then
        close_redis(red)
        return response(500, 1, 'error to save to global versions')
      end
      local res, err = red:hmset(
        'version:' .. var_name .. ':' .. value,
        'value', value, 'name', name, 'weight', weight,
        'var_name', var_name, 'modified', ngx.time()
      )
      if err then
        close_redis(red)
        return response(500, 1, 'error to save version')
      end

      close_redis(red)
      response(200, 0, 'edit test success')
    }
  }
  location = /ab/test/rate {
    content_by_lua_block {
      local var_name = arg('var')
      local red = connect_redis()
      local res, err = red:sismember("vars", var_name)
      if err or res == 0 then
        close_redis(red)
        return response(404, 1, 'var_name: ' .. var_name .. ' not exists, edit var failed.')
      end
      local targets, err = red:smembers("targets:" .. var_name)
      if err then
        close_redis(red)
        return response(404, 1, 'can not get target by var_name: ' .. var_name)
      end
      ngx.log(ngx.ERR, 'get targets by var_name: ', var_name)
      local args = {
        'value:' .. var_name, 'by', 'nosort',
        'get', '#',
        'get', 'version:' .. var_name .. ':*->var_name',
        'get', 'version:' .. var_name .. ':*->weight',
        'get', 'version:' .. var_name .. ':*->name',
        'get', 'version:' .. var_name .. ':*->pv',
        'get', 'version:' .. var_name .. ':*->uv',
        -- 'get', 'version:' .. var_name .. ':*->uv:min',
        -- 'get', 'version:' .. var_name .. ':*->uv:max',
      }
      for i, target in ipairs(targets) do
        ngx.log(ngx.ERR, 'target: ', target)
        table.insert(args, 'get')
        table.insert(args, 'version:' .. var_name .. ':*->' .. target .. ':count')
        table.insert(args, 'get')
        table.insert(args, 'version:' .. var_name .. ':*->' .. target .. ':user')
        -- table.insert(args, 'get')
        -- table.insert(args, 'version:' .. var_name .. ':*->' .. target .. ':min')
        -- table.insert(args, 'get')
        -- table.insert(args, 'version:' .. var_name .. ':*->' .. target .. ':max')
      end
      ngx.log(ngx.ERR, 'sort: ', cjson.encode(args))
      local versions, err = red:sort(unpack(args))
      if err then
        close_redis(red)
        return response(500, 1, 'get versions failed')
      end

      close_redis(red)
      set_headers()
      ngx.print(cjson.encode({
        code=0, msg='success',
        versions=versions,
        targets=targets,
      }))
      ngx.exit(200)
    }
  }
  location = /ab/versions {
    content_by_lua_block {
      local red = connect_redis()
      local res, err = red:sort(
        'versions', 'by', 'nosort',
        'get', '#', 'get', 'version:*->var_name', 'get', 'version:*->name',
        'get', 'version:*->value', 'get', 'version:*->weight',
        'get', 'version:*->pv', 'get', 'version:*->uv',
        'get', 'version:*->created', 'get', 'version:*->modified'
      )
      if err then
        close_redis(red)
        return response(500, 1, 'get target failed')
      end
      close_redis(red)
      set_headers()
      ngx.print(cjson.encode({
        code=0, msg='success',
        versions=res,
      }))
      ngx.exit(200)
    }
  }
  location = /ab/targets {
    content_by_lua_block {
      local red = connect_redis()
      local res, err = red:sort(
        'targets', 'by', 'nosort',
        'get', '#', 'get', 'target:*->var_name',
        'get', 'target:*->count', 'get', 'target:*->rate'
      )
      if err then
        close_redis(red)
        return response(500, 1, 'get target failed')
      end
      close_redis(red)
      set_headers()
      ngx.print(cjson.encode({
        code=0, msg='success',
        targets=res,
      }))
      ngx.exit(200)
    }
  }
  location = /ab/target/add {
    content_by_lua_block {
      local var_name = arg('var')
      local target_name = arg('target')

      local red = connect_redis()
      local res, err = red:sismember("vars", var_name)
      if err or res == 0 then
        close_redis(red)
        return response(404, 1, 'var_name: ' .. var_name .. ' not exists, add target failed.')
      end
      local res, err = red:sismember("targets", target_name)
      if err or res > 0 then
        close_redis(red)
        return response(500, 1, 'target_name: ' .. target_name .. ' exists, add target failed.')
      end
      local res, err = red:sadd("targets", target_name)
      if err then
        close_redis(red)
        return response(500, 1, 'add target: ' .. target_name .. ' failed.')
      end
      local res, err = red:sadd("targets:" .. var_name, target_name)
      if err then
        close_redis(red)
        return response(500, 1, 'add target: ' .. target_name .. ' to var_name: ' .. var_name .. ' failed.')
      end
      local res, err = red:hmset('target:' .. target_name, 'var_name', var_name, 'created', ngx.time(), 'modified', ngx.time())
      if err then
        close_redis(red)
        return response(500, 1, 'save target: ' .. target_name .. ' with var_name: ' .. var_name .. ' failed.')
      end

      close_redis(red)
      response(200, 0, 'add target success')
    }
  }
  location = /ab/var {
    auth_basic off;
    content_by_lua_block {
      local user_id = get_user_id()
      local var_name = arg('name')
      local red = connect_redis()
      local res, err = red:sismember("vars", var_name)
      if err or res == 0 then
        close_redis(red)
        return response(404, 1, 'var_name: ' .. var_name .. ' not exists, get val failed.')
      end

      local res, err = red:hgetall('var:' .. var_name)
      if err or res == ngx.null then
        close_redis(red)
        return response(404, 1, 'can not find test by var_name: ' .. var_name)
      end
      local test = red:array_to_hash(res)
      ngx.log(ngx.ERR, "get var by name: ", var_name, test.status)
      if test.status ~= 'running' then
        close_redis(red)
        return response_value(test.default, test)
      end
      local val, err = red:hget('user:value:' .. var_name, user_id)
      ngx.log(ngx.ERR, "get val by var_name: ", var_name, val)
      if err or val == ngx.null then
        local layer_weight, err = red:zscore('layer:' .. test.layer, var_name)
        if layer_weight and layer_weight ~= ngx.null and tonumber(layer_weight) > 0 then
          layer_weight = tonumber(layer_weight)
        end
        local cursor = "0"
        local random, real_weight = math.random(), 0
        repeat
          local vals, err = red:zscan('value:' .. var_name, cursor, "count", 100)
          if not vals then
            close_redis(red)
            return response(500, 1, 'failed to scan vals, var_name: ' .. var_name)
          else
            local data, i, c, weight, v
            cursor, data = unpack(vals)
            if #data > 0 then
              for i, c in ipairs(data) do
                  if i % 2 == 1 then
                    v = c
                  end
                  if i % 2 == 0 then
                    weight = c
                    ngx.log(ngx.ERR, "weight for val: ", weight, v)
                    if tonumber(c) > 0 then
                      real_weight = real_weight + tonumber(c) * layer_weight / 10000
                      ngx.log(ngx.ERR, "real weight for val: ", real_weight, v, random)
                      if random < real_weight then
                        val = v
                        local res, err = red:hset('user:value:' .. var_name, user_id, val)
                        if err then
                          close_redis(red)
                          return response(500, 1, 'save user_val failed, var_name: ' .. var_name .. ' user_id: ' .. user_id .. ' val: ' .. val)
                        end
                        red:zincrby('uv:' .. var_name .. ':' .. val, 1, user_id)
                        close_redis(red)
                        return response_value(val, test)
                      end
                    end
                  end
              end
            end
          end
        until cursor == "0"
      end
      local value = test.default
      local res, err = red:hset('user:value:' .. var_name, user_id, value)
      if err then
        close_redis(red)
        return response(500, 1, 'save user_val failed, var_name: ' .. var_name .. ' user_id: ' .. user_id .. ' value: ' .. value)
      end
      red:zincrby('uv:' .. var_name .. ':' .. value, 1, user_id)
      close_redis(red)
      response_value(value, test)
    }
  }
  location = /ab/track {
    auth_basic off;
    content_by_lua_block {
      ngx.req.read_body()
      local user_id = get_user_id()
      local data = ngx.req.get_body_data()
      local red = connect_redis()
      if data then
        local params = cjson.decode(data)
        ngx.log(ngx.ERR, "body: ", data)
        for target, inc in pairs(params) do
          ngx.log(ngx.ERR, "target: ", target, " --> ", inc)
         
          local red = connect_redis()
          local res, err = red:sismember("targets", target)
          if err or res == 0 then
            close_redis(red)
            return response(404, 1, 'target: ' .. target .. ' not exists')
          end
          local var_name, err = red:hget('target:' .. target, 'var_name')
          if err or var_name == ngx.null then
            close_redis(red)
            return response(404, 1, 'can not find var_name, target: ' .. target)
          end
          local val_name, err = red:hget('user:value:' .. var_name, user_id)
          if err or val_name == ngx.null then
            close_redis(red)
            return response(404, 1, 'can not find val_name, var_name: ' .. var_name)
          end
          -- ngx.log(ngx.ERR, "var_name: ", var_name, "val_name: ", val_name, "target: ", target)
          local key = 'track:' .. var_name .. ':' .. val_name .. ':' .. target
          local res, err = red:zincrby(key, inc, user_id)
          if err then
            close_redis(red)
            return response(404, 1, 'incrby ' .. user_id .. ' failed. key: ' .. key)
          end
        end
      end

      close_redis(red)
      response(200, 0, 'save track success')
    }
  }
  location / {
    root /var/www/html;
    try_files $uri $uri/ /index.html;
  }
  auth_basic           "AB test";
  auth_basic_user_file /etc/nginx/htpasswd; 
}
